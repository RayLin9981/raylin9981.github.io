{"pages":[{"title":"page test","text":"這是 H1 的1相關指令：chmod chown umask","link":"/page-test/index.html"},{"title":"page test","text":"","link":"/page-test/index-1.html"}],"posts":[{"title":"初始教學頁面保留一下","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/09/02/hello-world/"},{"title":"有顏色的shell：zsh 簡易安裝與使用心得","text":"為何要使用 zsh?先上結果 之前在看一些 it 邦幫忙的文章的時候，就有發現有不少人的 shell 色彩繽紛 而且重點是他們的 GIF 圖的範例裡面，有時候指令就莫名其妙的打完了 (不是使用 Tab) 於是呢，就想說也來練習看看，但他好像也不是什麼新東西了 單純做個筆記分享一下 安裝程式碼紀錄1234567891011121314151617181920212223242526272829303132333435363738# centos 7 2021.11 測試# 使用 centos 7.4 最小版安裝# 確保 zsh 版本高於 5.1 ( centos 7 預設的 repo 的只有5.0.1的樣子)# 建議 sudo 設定 NOPASSWD 比較輕鬆安裝sudo yum update -ysudo yum install -y git make ncurses-devel gcc autoconf man yodl wget# 去下載 zsh-5.7.1 的版本來編譯git clone -b zsh-5.7.1 https://github.com/zsh-users/zsh.git /tmp/zshcd /tmp/zsh./Util/preconfig./configuresudo make -j 20 installcd ~# 安裝 ohmyzshwget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.shyes | sh install.sh# p10kgit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k#在 ~./zshrc 中加入 ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;# 接下來重新載入 zsh 會進入設定模式，可依據自己的喜好選擇，後生成 ~/.p10kzsh# 安裝 you-should-usegit clone https://github.com/MichaelAquilina/zsh-you-should-use.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/you-should-use# 在 ~/.zshrc 的 plugin 中新增 you-should-use# zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions# 在 ~/.zshrc 的 plugin 中新增 zsh-autosuggestions#zsh-completionsgit clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions# 下載我自己的 config , 這段可跳過git clone https://github.com/RayLin9981/config.gitcp config/.p10k.zsh .cp config/.zshrc . 可以看到有安裝了 zsh , ohmyzsh,powerlevel10k, zsh-autosuggestions , zsh-completions 等等，其實並不多，但我覺得用起來跟 bash 比起來還是方便很多 Oh My ZSH!這個開源程式主要是用來管理 zsh 的一些 plugins , 等等要安裝的 plugins 都會丟到 ~/.oh-my-zsh 的目錄裡面 Oh My ZSH 似乎是導致 zsh 開始變紅的一個因素之一，有看過一篇文是說 Oh My ZSH 出來之後在 google 搜尋上 zsh 的搜尋頻率提升很多 (離題了) 並且可以到他的官方網站去挑選主題來用，主題多到用滾輪滑也要滑很久才滑的完 但我的主題是使用 powerlevel10k powerlevel10k主要讓畫面變得鮮豔的道具~ 在第一次下載時，到 在 ~./zshrc 中加入 ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; 後進入 zsh 就會有一個互動介面，可以依循他的步驟挑選自己喜歡的模樣 結束後若想再重新設定一次 ，可輸入 p10k configure 再進入互動介面 若是想要更客製化，可以去編輯 ~/.p10k.zsh 這個檔案，裡面有非常多的東西可以修改 e.g. POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS 這個變數顧名思義就是要控制畫面右方顯示的東西，以我的畫面為例，我有新增了 ip 這個功能，就可以看到目前主要的 interface 的 IP ，省去我每次在多台電腦切來切去的時候都會忘記 IP 是多少 能客製化的東西非常多，也可以監控 CPU,memory 等系統資源，也可以自己定義圖示 (就不用顯示醜醜的 CPU 三個字)，不過我就沒有多加研究，這個可以到網路上找別人的範本來改 you-should-use下載完之後，到 ~/.zshrc 的 plugins 新增 you-should-use (用空白隔開，或是一行一行的也可以) 那這個套件呢，主要是搭配上 Linux 的 alias 功能，非常實用 因為在 ~/.zshrc 中的 plugins 有新增指令的話，他就會幫忙產生很多好用的 ailas，以我的檔案來說： 1234plugins=(git you-should-use zsh-autosuggestions zsh-completions kubectl ) # 請注意 kubectl 這行alias | grep kubectl | wc -l94 他自動幫我設定這些，就算很好用也根本記不住，但是 you should use 就會在我執行的時候告訴我應該要用有設定的 ailas ，被多提醒幾次之後要不記住也難啦~ 所以上面的指令kubectl apply -f ~/test 就可以簡化成 kaf ~/test 輕鬆又自在 zsh-autosuggestions &amp; zsh-completionzsh-completion 這個就是跟 bash-completion 差不多的功能，只要拔掉 Tab 就會立刻喪失能力的我，跳到 zsh 來也是立刻就先把這個準備好了 簡單說一下，他可以跟 kubectl (當然指令大多數都可以) 互動，比如我打 kubectl get pods -n [Tab] 的時候，他就會顯示 -n 能輸入什麼參數 (也就是我目前環境內的 namespace)，不裝他的話真的一堆指令都記不住了 XD zsh-autosuggestions 也是很好用的一個 plugins , 他會依據你曾經輸入過的指令給你建議 (用比較淺的顏色) ，如果那是你要的就直接按 方向鍵的右鍵 ，他就會自動幫你補全 預設是只有去追蹤 history ，但我覺得 completion 的功能也很好用，所以就有補上去 可以到 .oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh 裡面的 ZSH_AUTOSUGGEST_STRATEGY=(history completion ) 做這樣的調整 總結以現在一個月左右學習 kubernetes 用起來，zsh 還蠻舒服的，善用這些 plugins 的確可以減短打很多字的時間呢~ 這篇文章比我想像中的還晚生出來 XD” ，接下來會繼續加把勁的~~ 參考資料zsh安裝主要參考文章 改變windows 編碼，不然會看不到 powerlevel 的字型設定 p10k安裝字型等 VMware player 開機順序調整","link":"/2021/11/15/%E6%9C%89%E9%A1%8F%E8%89%B2%E7%9A%84shell%EF%BC%9Azsh-%E7%B0%A1%E6%98%93%E5%AE%89%E8%A3%9D%E8%88%87%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"},{"title":"真正的 home brew 測試","text":"This template explains our QA process for shipping bug-free software. brew tap homebrew/boneyard 有一個好用的指令 versions ，但現在不支援了 看到一篇文說 ，似乎把舊版的repo 都刪掉了 I read all the answers. It’s 2020 and there is no easy way or official command to do that 沒有好的 downgrade 方法 😢 第十三章、Linux 帳號管理與 ACL 權限設定","link":"/2021/09/02/%E7%9C%9F%E6%AD%A3%E7%9A%84-home-brew-%E6%B8%AC%E8%A9%A6/"},{"title":"第一篇：自我介紹與部落格方針","text":"前言大家好，我是林禹志，這是這網站的第一篇文，會簡單的描述一下我的心路歷程與創建部落格的規劃 首先我必須要說，因為我還很菜沒有什麼實務經驗，所以以下的內容會依照我目前的理解來寫，可能會有很多錯誤的部分，敬請見諒~ 第一次使用雲端 (AWS)第一次接觸到雲端是大學時系上有一位教授 (黃懷陞 教授，下稱 Cage ) 是 AWS 的合作夥伴，利用 AWS educate 的資格開了兩門選修課，我對雲端很感興趣就選了 在那時還不懂網路架構等等的東西，所以用到最多的就是 EC2 當作虛擬機使用而已，其他服務就是聽聽理論 (如： AWS S3 能夠給予幾個9的可用性等等的)，有點沒辦法融會貫通。不過我認為雲端是未來的趨勢，後來也請 Cage 作為我們專題的指導教授，繼續跟著他學習。 第一次參加社群活動 (2019 COSCUP)能夠接觸到這塊，也是 Cage 要我們去找找專題的靈感。那時候我還沒有接觸過 Linux ，甚至連 Ubuntu 也沒聽過，有點像劉姥姥進大觀園，幾乎什麼都看不懂聽不懂 XD 其中有一場議程讓我比較印象深刻，主題叫 ：「帶你了解 grep 的背後原理」，想當然，我那時也沒用過這個指令，我就給了自己一個小小的目標 「我明年的 COSCUP，至少要知道 grep 是什麼!」 現在來看，確實是一個非常小的目標，但那時候我還很習慣老師教什麼我就學什麼，還不太會自己上網學習新的東西(還待在舒適圈) 總之，開啟了一個很大的門，裡面有著無數的知識等著挖掘。 實習安排的社群大大演講收穫在一年的實習中，總算是學習到了比較完整的 Linux 操作 (Red Hat) ，不過實習的內容想要下一段再講，這邊想先講社群大大的演講。 公司邀請到了 Phil 與 Rico 兩位講師，現在發現都是在 CNTUG 的大大們呢~ Rico 主要是講如何貢獻開源專案(openstack)，但因為我現在還沒有開始貢獻，所以還沒有什麼體悟 倒是 Phil 主要是談論自學的一些經驗等等，現在比較有感 Phil 在剛開始講的時候就說 ： 「我要講的東西很困難，要像我一樣有病才有可能堅持下去」 「我不期望我講完能讓台下所有人都動起來，現在台下大概20幾個人，我只要能啟發一個人，這場演講就成功了」 我大概也不算被啟發的，畢竟也是過了快一年多才發覺到自學的重要性 「喔還有，我通常只記得女生，男生的話不要過來跟我裝熟」 演講內容其實大概是分享一下 Phil 讀研究所的一些經歷等等，還有可以去改 .vimrc 當作自學的目標啊之類的 我記最深的是，QA時我問 Phil ：「我最近在自學 D Jango (發音錯)，不知道您能不能給我一些建議？」 他就回我：「你發音錯了吧？ django?」 然後也沒回答我的問題，大概說了三次我發音錯了XD 還有我回答問題，Phil 有準備貼紙獎勵，過去一看都是沒看過的東東，就選了一個可愛的三地鼠(podman) Phil 就跟我分享一下最近他有在研究這個 pod 管理程式這樣 當時聽的似懂非懂，不過現在才知道原來 podman 基本用起來跟 docker 差不多呢 (基本) 大概是這樣 實習時，自學openstack的痛苦經歷沒錯，是痛苦的經歷，有點像是越級打怪這樣，一大堆看都看不懂的名詞，安裝文件裡面預期有的基礎知識我幾乎都沒有，所以就只能看一看，然後照著文件內的指令照做，就變成了以下的循環： 「欸，失敗了欸，怎麼會失敗呢」 (把錯誤訊息丟 google ，隨便亂改參數或.yaml檔再執行) 「欸！成功了欸！怎麼會成功呢！？」 這樣的流程大概跑了10-20次吧，搞了半年，總算是把 Red Hat openstack 的基本架構架起來了 然後，實習就結束了，現在回去看我那時候的安裝筆記，裡面就全部是我改了哪些檔案，哪個參數等等，部署的指令可能排列組合起來就有幾百種 更要命的是 ， overcloud 在部署的時候，指令跑下去有時候就要半小時 (如果參數錯在後面的步驟) 也就是我測試上百個的參數，每天就是在執行指令，然後看著黑畫面開始拜託他成功。 現在看來是一個很糟糕的自學心態，不過那時候有每個禮拜的進度壓力，再加上接學校助教每個禮拜都要備課等等的 最大的收穫大概是知道自己是有多廢吧(? ，也確立了後面激起自學的心 把那時候不懂的名詞記一下：L2,L3 ,HAproxy,Puppet,vxlan,gateway(對，就是那個gateway) , 認識 CNTUG (COSCUP 2021)今年因為疫情的關係，COSCUP 改為線上舉辦，改使用 Gather town 進行議程，每一個議程軌也改成講師預先錄好影片後再播放 我就和前兩年參與的模式一樣，先規劃一下有興趣的主題，再來看看要看什麼，注意到了大部分我有興趣的主題都是 CNTUG 的議程軌 其中 Gene Guo 大大的 「從零打造自己的 Home Lab」 主題很吸引我，因為正有打算來自建一個 Home Lab 來練習 openstack 用 (他的 lab 也是有用 openstack 架構) 不過內容還是有很多聽不懂的部分，我也盡可能的做成筆記囉 最重要的是，受惠於線上舉辦，我也總算鼓起勇氣在虛擬會場上找到了 Gene Guo 大大聊聊。 主要就提到了前面 openstack 的慘痛學習經驗，他也給了我一些關鍵字(OVS,OVN)等，也建議我可以一個一個元件來裝 (RHEL 的就是一次全包) ，再來慢慢了解。 日後的學習方針與部落格規劃上面就大概講了一下會走到現在這步(? 的情況 在前面這段時間(2021/7-9) ，把 Cisco CCNA 證照的內容讀了一下，總算是對網路架構有了比較完整的了解，也把 Red Hat 的 RHCSA 證照拿到手了，接下來會繼續往 docker,k8s,openstack(ovs,ovn) 等等學習，也因為我還很多東西不會，所以希望能提供給跟我一樣的人一些啟發，一起學習進步這樣 目前大概會參考 phil 的 home lab ，也來搞一個自己的文章或是先寫政府課的心得(SRE 課程，要上到11/30)，內容有包含 k8s 與 container 等，或許有什麼新的體悟也可以來更新文章 大概就是這樣，也期許自己能夠繼續堅持下去囉 感謝你對我有興趣把這篇落落長的第一篇文章看完~~~ 後記最近和一位在企業管伺服器的講師聊到 openstack ，結果他一聽到回我三個字「爛東西」 實在是一個很令人意外的答案XD” ，不過我應該還是會用用看才能知道「爛」在哪邊吧","link":"/2021/09/19/%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%9A%E8%87%AA%E6%88%91%E4%BB%8B%E7%B4%B9%E8%88%87%E9%83%A8%E8%90%BD%E6%A0%BC%E6%96%B9%E9%87%9D/"},{"title":"nginx images 的 docker-entrypoint.sh 閱讀","text":"前言因為現在 Cloud-native 的觀念越來越盛行，container image 是基礎如果要自己寫 image 的話，就有一些眉角需要注意一下，其中一個我覺得蠻重要的就是 entrypoint 的設計 (如果設計不好可能 container 隨時就掛了) 之前也有用過 mysql 的 image, 他提供了一個 docker-entrypoint.d 來讓使用者放入 .sh,.sql 檔案，這樣在啟動的時候就可以預先載入使用者寫好的資料表，之後有機會再來深入探究那這次使用的 image 為 dockerhub.io/nginx:1.20先使用 docker inspect nginx:1.20 來觀察一下他的 entrypoint, cmd 分別是怎麼設計的 /entrypoint.sh 觀察 可看到 entrypoint 為 /docker-entrypoint.sh 這隻程式cmd 則為 nginx -g daemon off接下來就可以直接看 /docker-entrypoint.sh 是如何設計的 /docker-entrypoint.sh 完整檔案 1234567891011121314151617181920212223242526272829303132#!/bin/sh# vim:sw=4:ts=4:etset -eif [ -z &quot;${NGINX_ENTRYPOINT_QUIET_LOGS:-}&quot; ]; then exec 3&gt;&amp;1else exec 3&gt;/dev/nullfiif [ &quot;$1&quot; = &quot;nginx&quot; -o &quot;$1&quot; = &quot;nginx-debug&quot; ]; then if /usr/bin/find &quot;/docker-entrypoint.d/&quot; -mindepth 1 -maxdepth 1 -type f -print -quit 2&gt;/dev/null | read v; then echo &gt;&amp;3 &quot;$0: /docker-entrypoint.d/ is not empty, will attempt to perform configuration&quot; echo &gt;&amp;3 &quot;$0: Looking for shell scripts in /docker-entrypoint.d/&quot; find &quot;/docker-entrypoint.d/&quot; -follow -type f -print | sort -V | while read -r f; do case &quot;$f&quot; in *.sh) if [ -x &quot;$f&quot; ]; then echo &gt;&amp;3 &quot;$0: Launching $f&quot;; &quot;$f&quot; else # warn on shell scripts without exec bit echo &gt;&amp;3 &quot;$0: Ignoring $f, not executable&quot;; fi ;; *) echo &gt;&amp;3 &quot;$0: Ignoring $f&quot;;; esac done echo &gt;&amp;3 &quot;$0: Configuration complete; ready for start up&quot; else echo &gt;&amp;3 &quot;$0: No files found in /docker-entrypoint.d/, skipping configuration&quot; fifiexec &quot;$@&quot; 接下會以兩個區段來看，分別是： 基本設定區段 docker-entrypoint.d 目錄檢查區段 1.基本設定區段1234567891011121314#!/bin/sh# vim:sw=4:ts=4:et# set -e 遇到錯誤直接結束程式set -e# 檢查變數if [ -z &quot;${NGINX_ENTRYPOINT_QUIET_LOGS:-}&quot; ]; then exec 3&gt;&amp;1else exec 3&gt;/dev/nullfi# 這邊先這樣，主要是搭配最後的 exec if [ &quot;$1&quot; = &quot;nginx&quot; -o &quot;$1&quot; = &quot;nginx-debug&quot; ]; then...exec &quot;$@&quot; 先把開頭跟結尾分開來第二行的 vim:sw=4;ts=4;et 是跟 vim 編輯器縮排的有關set -e 則是當程式內有回傳非 0 時 (表示執行失敗) 就立刻結束接下來的 if [ -z &quot;${NGINX_ENTRYPOINT_QUIET_LOGS:-}&quot; ] 則是檢查這個環境變數是否有存在，有的話則會把 Log 透過管線丟出來，否則就丟到 /dev/null最後透過 $1 來檢查 cmd 是帶什麼，如果是 nginx, nginx-debug 其中兩個就會開始執行裡面主要的邏輯判斷在執行 docker run 時如果沒帶入任何參數，則預設為 nginx -g daemonoff 就符合 nginx 的情況最後放進 exec &quot;$@&quot; 代表任何帶入的 cmd 都會執行舉個例子，假設我使用 docker run -it nginx:1.20 cat /docker-entrypoint.sh 來開啟 container根據 entrypoint 的設定，還是會執行 docker-entrypoint.sh, 而這邊的 $1 就變成了 cat, if 就不會成立就會執行最後的 exec &quot;$@&quot;, 所以執行完 cat 指令後 container 就會關掉了這個應該就是增加 image 彈性的關鍵，不要讓使用者亂輸入 cmd 之後，image 整個壞掉 docker-entrypoint.d 目錄檢查區段延續上面最後的 if [ &quot;$1&quot; = &quot;nginx&quot; -o &quot;$1&quot; = &quot;nginx-debug&quot; ]; then 1234567891011121314151617181920212223242526...if [ &quot;$1&quot; = &quot;nginx&quot; -o &quot;$1&quot; = &quot;nginx-debug&quot; ]; then# 檢查是否有 '至少一個' 檔案 if /usr/bin/find &quot;/docker-entrypoint.d/&quot; -mindepth 1 -maxdepth 1 -type f -print -quit 2&gt;/dev/null | read v; then echo &gt;&amp;3 &quot;$0: /docker-entrypoint.d/ is not empty, will attempt to perform configuration&quot; echo &gt;&amp;3 &quot;$0: Looking for shell scripts in /docker-entrypoint.d/&quot; find &quot;/docker-entrypoint.d/&quot; -follow -type f -print | sort -V | while read -r f; do case &quot;$f&quot; in *.sh) if [ -x &quot;$f&quot; ]; then echo &gt;&amp;3 &quot;$0: Launching $f&quot;; &quot;$f&quot; else # warn on shell scripts without exec bit echo &gt;&amp;3 &quot;$0: Ignoring $f, not executable&quot;; fi ;; *) echo &gt;&amp;3 &quot;$0: Ignoring $f&quot;;; esac done echo &gt;&amp;3 &quot;$0: Configuration complete; ready for start up&quot; else echo &gt;&amp;3 &quot;$0: No files found in /docker-entrypoint.d/, skipping configuration&quot; fifi 當確定好 $1 = nginx 後，會再使用 find 指令來檢查 /docker-entrypoint.d/ 目錄，並且帶入 -mindepth 1 -maxdepth 1 確保只會找到 /docker-entrypoint.d/ 目錄內的檔案 (如 /docker-entrypoint.d/a/a.sh 就不會被找到)但第一個 if 的 find 還帶入了 -quit, 用意只是確保 /docker-entrypoint.d/ 目錄有 至少一個 .sh 檔案需要執行接下來確定有檔案後就執行 find &quot;/docker-entrypoint.d/&quot; -follow -type f -print | sort -V | while read -r f; 開始把所有的檔案抓出來執行裡頭使用了 case 來把 .sh 的檔案與其他的檔案區隔開來，只執行 *.sh 並且擁有執行權限的檔案 ( 使用 [ -x &quot;$f&quot; ] 檢查)while read 結束後印出 Configuration complete; ready for start up 告知使用者這個檔案的內容大致上就是這樣 實際執行結果後面有日期的那個是 nginx 開啟的訊息，可以看到 docker.entrypoint.sh 會把每一個執行的 .sh 顯示出來，真是貼心 後記在寫 dockerfile 的時候都會覺得 entrypoint 的設計很困難，為了讓自己能寫一些不只自己能使用的 image, 參考這種官方的 image 感覺是挺不錯的 (不會的話先模仿別人總沒問題了吧!!)其中在看這份 docker-entrypoint.sh 時，覺得最後一行 exec $@ 真是精隨，這樣就不會在使用者亂給 cmd 時顯示不該有的錯誤了 (當然也是搭配了上面的 if 來判斷才行)這篇文章大概就到這邊，如果有大大發現我寫的內容有問題歡迎指正我~~ 參考資料find man page stackoverflow: set -e dockerhub nginx 頁面","link":"/2022/04/18/nginx/"}],"tags":[],"categories":[]}